<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>pacmill.filtering.seq_filter API documentation</title>
<meta name="description" content="Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pacmill.filtering.seq_filter</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
&#34;&#34;&#34;

# Built-in modules #
from collections import Counter

# Internal modules #

# First party modules #
from fasta import FASTQ
from plumbing.cache import property_cached

# Third party modules #
import pandas

###############################################################################
class SeqFilter:
    &#34;&#34;&#34;
    This class takes care of filtering sequences from a FASTA or FASTQ file
    depending on certain criteria.

    - Filter primers:
       * Check that the primers are found where they should be found.
       * Check that the primers have the sequence they should have.

    - Filter based on presence of N bases.

    - Filter based on maximum and minimum sequence lengths.

    - Filter based on the minimum PHRED score of a sliding window.

    You can adjust several parameters:

    * primer_mismatches: Number of mismatches allowed before discarding.
    * primer_max_dist:   Maximum distance for primer presence before
                         discarding (counted in base pairs from sequence
                         start or end).
    * min_read_length:   Minimum sequence length.
    * max_read_length:   Maximum sequence length.
    * phred_window_size: The size of the rolling window (in base pairs) inside
                         which scores are averaged.
    * phred_threshold:   The quality score cutoff point for the average score
                         within any window.

    The final cleaned FASTQ is available at `self.results.clean`
    &#34;&#34;&#34;

    # Attributes #
    short_name = &#39;seq_filter&#39;

    # Default parameters #
    primer_mismatches = None
    primer_max_dist   = None
    min_read_len      = None
    max_read_len      = None
    phred_window_size = None
    phred_threshold   = None

    def __repr__(self):
        return &#39;&lt;%s object on %s&gt;&#39; % (self.__class__.__name__, self.sample)

    def __init__(self, sample):
        # Save the reference to a sample object #
        self.sample = sample
        # The different files #
        self.primers_fastq = FASTQ(self.autopaths.primers)
        self.n_base_fastq  = FASTQ(self.autopaths.n_base)
        self.length_fastq  = FASTQ(self.autopaths.length)
        self.score_fastq   = FASTQ(self.autopaths.score)
        self.renamed_fastq = FASTQ(self.autopaths.renamed)
        # The final result #
        self.clean = self.renamed_fastq

    #-------------------------- Automatic paths ------------------------------#
    all_paths = &#34;&#34;&#34;
                /primers.fastq
                /n_base.fastq
                /length.fastq
                /score.fastq
                /renamed.fastq
                &#34;&#34;&#34;

    @property_cached
    def autopaths(self):
        &#34;&#34;&#34;
        The AutoPaths object is used for quickly assessing the filesystem paths
        of various file inputs/outputs and directories.
        See https://github.com/xapple/autopaths#autopaths-object
        &#34;&#34;&#34;
        from autopaths.auto_paths import AutoPaths
        return AutoPaths(self.sample.autopaths.filtered_dir, self.all_paths)

    #-------------------------------- Running --------------------------------#
    def __call__(self, verbose=False):
        # Message #
        if verbose: print(&#34;Filtering sample &#39;%s&#39;&#34; % self.sample.short_name)
        # Primers #
        self.primer_filter()
        # N bases #
        self.n_base_filter()
        # Length #
        self.len_filter()
        # Score #
        self.score_filter()
        # Rename with a number #
        self.score_fastq.rename_with_num(self.sample.short_name + &#39;:&#39;,
                                         self.renamed_fastq)
        # Check #
        if len(self.score_fastq) == 0:
            msg = &#34;No results left after filtering the sample &#39;%s&#39;.&#34;
            raise Exception(msg % self.sample.short_name)
        # Return #
        return self.results.clean

    #-------------------------------- Primers --------------------------------#
    def primer_gen(self, reads, verbose=False, debug=False):
        &#34;&#34;&#34;
        We will uses regex patterns to search every read for both primers.
        We will record the start and end positions of primers when they are
        found. Both the forward and reverse primers are searched for.
        Both the original sequences and their reverse complements are
        searched for, in case the read is on the opposite strand.
        &#34;&#34;&#34;
        # Select verbosity #
        import tqdm
        wrapper = tqdm.tqdm if verbose else lambda x: x
        # Shorter name for the distance allowed #
        dist = self.primer_max_dist
        # Loop #
        for r in wrapper(reads):
            # Use this for debugging purposes #
            if debug: print(r.pretty_visualization)
            # Did we find both primers? #
            fwd_found = r.fwd_srt is not None or r.fwd_rc_srt is not None
            rev_found = r.rev_srt is not None or r.rev_rc_srt is not None
            # Skip reads that don&#39;t pass this criteria #
            if not fwd_found or not rev_found: continue
            # These situations should not occur, could be long chimeras #
            if r.fwd_srt is not None    and r.rev_srt is not None:    continue
            if r.fwd_rc_srt is not None and r.rev_rc_srt is not None: continue
            # We are in a forward sequence situation #
            if r.fwd_srt is not None and r.rev_rc_srt is not None:
                if dist and r.fwd_srt                 &gt; dist: continue
                if dist and len(r.seq) - r.rev_rc_end &gt; dist: continue
                out = r.read[r.fwd_end:r.rev_rc_srt]
                if len(out) == 0: continue
            # We are in a reverse complemented situation #
            if r.fwd_rc_srt is not None and r.rev_srt is not None:
                if dist and r.rev_srt                 &gt; dist: continue
                if dist and len(r.seq) - r.fwd_rc_end &gt; dist: continue
                out = r.read[r.rev_end:r.fwd_rc_srt].reverse_complement()
                if len(out) == 0: continue
            # Return #
            yield out

    def primer_filter(self):
        &#34;&#34;&#34;
        Will take only reads that have both primers in the correct position
        and with the correct sequence. Will also trim the primers once found.
        &#34;&#34;&#34;
        # This will return a generator object with a length property #
        all_reads = self.sample.fastq.parse_primers(self.sample.primers,
                                                    self.primer_mismatches)
        # Write #
        self.primers_fastq.write(self.primer_gen(all_reads))

    #------------------------------ N bases ----------------------------------#
    def n_base_gen(self, reads):
        for r in reads:
            if &#39;N&#39; in r: continue
            yield r

    def n_base_filter(self):
        self.n_base_fastq.write(self.n_base_gen(self.primers_fastq))

    #------------------------------- Length ----------------------------------#
    def len_gen(self, reads, verbose=False):
        for r in reads:
            if self.min_read_len &gt; 0:
                if len(r.seq) &lt; self.min_read_len:
                    if verbose: print(&#34;Discard&#34;)
                    continue
            if self.max_read_len &gt; 0:
                if len(r.seq) &gt; self.max_read_len:
                    if verbose: print(&#34;Discard&#34;)
                    continue
            if verbose: print(&#34;Keep&#34;)
            yield r

    def len_filter(self):
        # Optionally bypass this step #
        if self.min_read_len is None and self.max_read_len is None:
            self.length_fastq.copy(self.n_base_fastq)
        # Perform the length filtering #
        self.length_fastq.write(self.len_gen(self.n_base_fastq))

    #-------------------------------- Score ----------------------------------#
    def score_gen(self, reads):
        # Parameters #
        window    = self.phred_window_size
        threshold = self.phred_threshold
        # Loop #
        for r in reads:
            quality = pandas.Series(r.letter_annotations[&#39;phred_quality&#39;])
            rolling = quality.rolling(window).mean().dropna().tolist()
            if any(score &lt; threshold for score in rolling): continue
            yield r

    def score_filter(self):
        # Optionally bypass this step #
        if self.phred_window_size is None or self.phred_threshold is None:
            self.score_fastq.copy(self.length_fastq)
        # Perform the score filtering #
        self.score_fastq.write(self.score_gen(self.length_fastq))

    #------------------------------ Debugging --------------------------------#
    @property_cached
    def primer_positions(self):
        &#34;&#34;&#34;Useful for diagnostics. Returns the primer positions counts.&#34;&#34;&#34;
        # Count positions #
        all_fwd_pos, all_rev_pos = Counter(), Counter()
        # Make a generator #
        all_reads = self.sample.fastq.parse_primers(self.sample.primers,
                                                    self.primer_mismatches)
        # Iterate over the generator #
        for r in all_reads():
            if r.fwd_start_pos is not None:
                all_fwd_pos.update((r.fwd_start_pos,))
            if r.rev_start_pos is not None:
                all_rev_pos.update((r.rev_start_pos,))
        # Return results #
        return all_fwd_pos, all_rev_pos

    #------------------------------- Results ---------------------------------#
    def __bool__(self):
        &#34;&#34;&#34;
        Return True if the filtering was run already and the results are
        stored on the filesystem. Return False if it was not yet run.
        &#34;&#34;&#34;
        return bool(self.renamed_fastq)

    @property_cached
    def results(self):
        # Check it was run #
        if not self:
            msg = &#34;You can&#39;t access results from the filtering procedure &#34; \
                  &#34;before running the algorithm.&#34;
            raise Exception(msg)
        # Return the results #
        return SeqFilterResults(self)

###############################################################################
class SeqFilterResults(object):

    def __init__(self, parent):
        # Reference to the SeqFilter instance #
        self.parent = parent
        # The intermediary steps #
        self.primers_fastq = parent.primers_fastq
        self.n_base_fastq  = parent.n_base_fastq
        self.length_fastq  = parent.length_fastq
        self.score_fastq   = parent.score_fastq
        self.renamed_fastq = parent.renamed_fastq
        # The final result #
        self.clean = self.renamed_fastq</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pacmill.filtering.seq_filter.SeqFilter"><code class="flex name class">
<span>class <span class="ident">SeqFilter</span></span>
<span>(</span><span>sample)</span>
</code></dt>
<dd>
<div class="desc"><p>This class takes care of filtering sequences from a FASTA or FASTQ file
depending on certain criteria.</p>
<ul>
<li>Filter primers:</li>
<li>Check that the primers are found where they should be found.</li>
<li>
<p>Check that the primers have the sequence they should have.</p>
</li>
<li>
<p>Filter based on presence of N bases.</p>
</li>
<li>
<p>Filter based on maximum and minimum sequence lengths.</p>
</li>
<li>
<p>Filter based on the minimum PHRED score of a sliding window.</p>
</li>
</ul>
<p>You can adjust several parameters:</p>
<ul>
<li>primer_mismatches: Number of mismatches allowed before discarding.</li>
<li>primer_max_dist:
Maximum distance for primer presence before
discarding (counted in base pairs from sequence
start or end).</li>
<li>min_read_length:
Minimum sequence length.</li>
<li>max_read_length:
Maximum sequence length.</li>
<li>phred_window_size: The size of the rolling window (in base pairs) inside
which scores are averaged.</li>
<li>phred_threshold:
The quality score cutoff point for the average score
within any window.</li>
</ul>
<p>The final cleaned FASTQ is available at <code>self.results.clean</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SeqFilter:
    &#34;&#34;&#34;
    This class takes care of filtering sequences from a FASTA or FASTQ file
    depending on certain criteria.

    - Filter primers:
       * Check that the primers are found where they should be found.
       * Check that the primers have the sequence they should have.

    - Filter based on presence of N bases.

    - Filter based on maximum and minimum sequence lengths.

    - Filter based on the minimum PHRED score of a sliding window.

    You can adjust several parameters:

    * primer_mismatches: Number of mismatches allowed before discarding.
    * primer_max_dist:   Maximum distance for primer presence before
                         discarding (counted in base pairs from sequence
                         start or end).
    * min_read_length:   Minimum sequence length.
    * max_read_length:   Maximum sequence length.
    * phred_window_size: The size of the rolling window (in base pairs) inside
                         which scores are averaged.
    * phred_threshold:   The quality score cutoff point for the average score
                         within any window.

    The final cleaned FASTQ is available at `self.results.clean`
    &#34;&#34;&#34;

    # Attributes #
    short_name = &#39;seq_filter&#39;

    # Default parameters #
    primer_mismatches = None
    primer_max_dist   = None
    min_read_len      = None
    max_read_len      = None
    phred_window_size = None
    phred_threshold   = None

    def __repr__(self):
        return &#39;&lt;%s object on %s&gt;&#39; % (self.__class__.__name__, self.sample)

    def __init__(self, sample):
        # Save the reference to a sample object #
        self.sample = sample
        # The different files #
        self.primers_fastq = FASTQ(self.autopaths.primers)
        self.n_base_fastq  = FASTQ(self.autopaths.n_base)
        self.length_fastq  = FASTQ(self.autopaths.length)
        self.score_fastq   = FASTQ(self.autopaths.score)
        self.renamed_fastq = FASTQ(self.autopaths.renamed)
        # The final result #
        self.clean = self.renamed_fastq

    #-------------------------- Automatic paths ------------------------------#
    all_paths = &#34;&#34;&#34;
                /primers.fastq
                /n_base.fastq
                /length.fastq
                /score.fastq
                /renamed.fastq
                &#34;&#34;&#34;

    @property_cached
    def autopaths(self):
        &#34;&#34;&#34;
        The AutoPaths object is used for quickly assessing the filesystem paths
        of various file inputs/outputs and directories.
        See https://github.com/xapple/autopaths#autopaths-object
        &#34;&#34;&#34;
        from autopaths.auto_paths import AutoPaths
        return AutoPaths(self.sample.autopaths.filtered_dir, self.all_paths)

    #-------------------------------- Running --------------------------------#
    def __call__(self, verbose=False):
        # Message #
        if verbose: print(&#34;Filtering sample &#39;%s&#39;&#34; % self.sample.short_name)
        # Primers #
        self.primer_filter()
        # N bases #
        self.n_base_filter()
        # Length #
        self.len_filter()
        # Score #
        self.score_filter()
        # Rename with a number #
        self.score_fastq.rename_with_num(self.sample.short_name + &#39;:&#39;,
                                         self.renamed_fastq)
        # Check #
        if len(self.score_fastq) == 0:
            msg = &#34;No results left after filtering the sample &#39;%s&#39;.&#34;
            raise Exception(msg % self.sample.short_name)
        # Return #
        return self.results.clean

    #-------------------------------- Primers --------------------------------#
    def primer_gen(self, reads, verbose=False, debug=False):
        &#34;&#34;&#34;
        We will uses regex patterns to search every read for both primers.
        We will record the start and end positions of primers when they are
        found. Both the forward and reverse primers are searched for.
        Both the original sequences and their reverse complements are
        searched for, in case the read is on the opposite strand.
        &#34;&#34;&#34;
        # Select verbosity #
        import tqdm
        wrapper = tqdm.tqdm if verbose else lambda x: x
        # Shorter name for the distance allowed #
        dist = self.primer_max_dist
        # Loop #
        for r in wrapper(reads):
            # Use this for debugging purposes #
            if debug: print(r.pretty_visualization)
            # Did we find both primers? #
            fwd_found = r.fwd_srt is not None or r.fwd_rc_srt is not None
            rev_found = r.rev_srt is not None or r.rev_rc_srt is not None
            # Skip reads that don&#39;t pass this criteria #
            if not fwd_found or not rev_found: continue
            # These situations should not occur, could be long chimeras #
            if r.fwd_srt is not None    and r.rev_srt is not None:    continue
            if r.fwd_rc_srt is not None and r.rev_rc_srt is not None: continue
            # We are in a forward sequence situation #
            if r.fwd_srt is not None and r.rev_rc_srt is not None:
                if dist and r.fwd_srt                 &gt; dist: continue
                if dist and len(r.seq) - r.rev_rc_end &gt; dist: continue
                out = r.read[r.fwd_end:r.rev_rc_srt]
                if len(out) == 0: continue
            # We are in a reverse complemented situation #
            if r.fwd_rc_srt is not None and r.rev_srt is not None:
                if dist and r.rev_srt                 &gt; dist: continue
                if dist and len(r.seq) - r.fwd_rc_end &gt; dist: continue
                out = r.read[r.rev_end:r.fwd_rc_srt].reverse_complement()
                if len(out) == 0: continue
            # Return #
            yield out

    def primer_filter(self):
        &#34;&#34;&#34;
        Will take only reads that have both primers in the correct position
        and with the correct sequence. Will also trim the primers once found.
        &#34;&#34;&#34;
        # This will return a generator object with a length property #
        all_reads = self.sample.fastq.parse_primers(self.sample.primers,
                                                    self.primer_mismatches)
        # Write #
        self.primers_fastq.write(self.primer_gen(all_reads))

    #------------------------------ N bases ----------------------------------#
    def n_base_gen(self, reads):
        for r in reads:
            if &#39;N&#39; in r: continue
            yield r

    def n_base_filter(self):
        self.n_base_fastq.write(self.n_base_gen(self.primers_fastq))

    #------------------------------- Length ----------------------------------#
    def len_gen(self, reads, verbose=False):
        for r in reads:
            if self.min_read_len &gt; 0:
                if len(r.seq) &lt; self.min_read_len:
                    if verbose: print(&#34;Discard&#34;)
                    continue
            if self.max_read_len &gt; 0:
                if len(r.seq) &gt; self.max_read_len:
                    if verbose: print(&#34;Discard&#34;)
                    continue
            if verbose: print(&#34;Keep&#34;)
            yield r

    def len_filter(self):
        # Optionally bypass this step #
        if self.min_read_len is None and self.max_read_len is None:
            self.length_fastq.copy(self.n_base_fastq)
        # Perform the length filtering #
        self.length_fastq.write(self.len_gen(self.n_base_fastq))

    #-------------------------------- Score ----------------------------------#
    def score_gen(self, reads):
        # Parameters #
        window    = self.phred_window_size
        threshold = self.phred_threshold
        # Loop #
        for r in reads:
            quality = pandas.Series(r.letter_annotations[&#39;phred_quality&#39;])
            rolling = quality.rolling(window).mean().dropna().tolist()
            if any(score &lt; threshold for score in rolling): continue
            yield r

    def score_filter(self):
        # Optionally bypass this step #
        if self.phred_window_size is None or self.phred_threshold is None:
            self.score_fastq.copy(self.length_fastq)
        # Perform the score filtering #
        self.score_fastq.write(self.score_gen(self.length_fastq))

    #------------------------------ Debugging --------------------------------#
    @property_cached
    def primer_positions(self):
        &#34;&#34;&#34;Useful for diagnostics. Returns the primer positions counts.&#34;&#34;&#34;
        # Count positions #
        all_fwd_pos, all_rev_pos = Counter(), Counter()
        # Make a generator #
        all_reads = self.sample.fastq.parse_primers(self.sample.primers,
                                                    self.primer_mismatches)
        # Iterate over the generator #
        for r in all_reads():
            if r.fwd_start_pos is not None:
                all_fwd_pos.update((r.fwd_start_pos,))
            if r.rev_start_pos is not None:
                all_rev_pos.update((r.rev_start_pos,))
        # Return results #
        return all_fwd_pos, all_rev_pos

    #------------------------------- Results ---------------------------------#
    def __bool__(self):
        &#34;&#34;&#34;
        Return True if the filtering was run already and the results are
        stored on the filesystem. Return False if it was not yet run.
        &#34;&#34;&#34;
        return bool(self.renamed_fastq)

    @property_cached
    def results(self):
        # Check it was run #
        if not self:
            msg = &#34;You can&#39;t access results from the filtering procedure &#34; \
                  &#34;before running the algorithm.&#34;
            raise Exception(msg)
        # Return the results #
        return SeqFilterResults(self)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pacmill.filtering.seq_filter.SeqFilter.all_paths"><code class="name">var <span class="ident">all_paths</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.max_read_len"><code class="name">var <span class="ident">max_read_len</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.min_read_len"><code class="name">var <span class="ident">min_read_len</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.phred_threshold"><code class="name">var <span class="ident">phred_threshold</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.phred_window_size"><code class="name">var <span class="ident">phred_window_size</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.primer_max_dist"><code class="name">var <span class="ident">primer_max_dist</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.primer_mismatches"><code class="name">var <span class="ident">primer_mismatches</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.short_name"><code class="name">var <span class="ident">short_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pacmill.filtering.seq_filter.SeqFilter.autopaths"><code class="name">var <span class="ident">autopaths</span></code></dt>
<dd>
<div class="desc"><p>The AutoPaths object is used for quickly assessing the filesystem paths
of various file inputs/outputs and directories.
See <a href="https://github.com/xapple/autopaths#autopaths-object">https://github.com/xapple/autopaths#autopaths-object</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.primer_positions"><code class="name">var <span class="ident">primer_positions</span></code></dt>
<dd>
<div class="desc"><p>Useful for diagnostics. Returns the primer positions counts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.results"><code class="name">var <span class="ident">results</span></code></dt>
<dd>
<div class="desc"><p>If you see the current source code in a seemingly unrelated part of
an auto-generated documentation, it means the program making the
documentation was unable to correctly traverse a decorated property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pacmill.filtering.seq_filter.SeqFilter.len_filter"><code class="name flex">
<span>def <span class="ident">len_filter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def len_filter(self):
    # Optionally bypass this step #
    if self.min_read_len is None and self.max_read_len is None:
        self.length_fastq.copy(self.n_base_fastq)
    # Perform the length filtering #
    self.length_fastq.write(self.len_gen(self.n_base_fastq))</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.len_gen"><code class="name flex">
<span>def <span class="ident">len_gen</span></span>(<span>self, reads, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def len_gen(self, reads, verbose=False):
    for r in reads:
        if self.min_read_len &gt; 0:
            if len(r.seq) &lt; self.min_read_len:
                if verbose: print(&#34;Discard&#34;)
                continue
        if self.max_read_len &gt; 0:
            if len(r.seq) &gt; self.max_read_len:
                if verbose: print(&#34;Discard&#34;)
                continue
        if verbose: print(&#34;Keep&#34;)
        yield r</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.n_base_filter"><code class="name flex">
<span>def <span class="ident">n_base_filter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def n_base_filter(self):
    self.n_base_fastq.write(self.n_base_gen(self.primers_fastq))</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.n_base_gen"><code class="name flex">
<span>def <span class="ident">n_base_gen</span></span>(<span>self, reads)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def n_base_gen(self, reads):
    for r in reads:
        if &#39;N&#39; in r: continue
        yield r</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.primer_filter"><code class="name flex">
<span>def <span class="ident">primer_filter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Will take only reads that have both primers in the correct position
and with the correct sequence. Will also trim the primers once found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def primer_filter(self):
    &#34;&#34;&#34;
    Will take only reads that have both primers in the correct position
    and with the correct sequence. Will also trim the primers once found.
    &#34;&#34;&#34;
    # This will return a generator object with a length property #
    all_reads = self.sample.fastq.parse_primers(self.sample.primers,
                                                self.primer_mismatches)
    # Write #
    self.primers_fastq.write(self.primer_gen(all_reads))</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.primer_gen"><code class="name flex">
<span>def <span class="ident">primer_gen</span></span>(<span>self, reads, verbose=False, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>We will uses regex patterns to search every read for both primers.
We will record the start and end positions of primers when they are
found. Both the forward and reverse primers are searched for.
Both the original sequences and their reverse complements are
searched for, in case the read is on the opposite strand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def primer_gen(self, reads, verbose=False, debug=False):
    &#34;&#34;&#34;
    We will uses regex patterns to search every read for both primers.
    We will record the start and end positions of primers when they are
    found. Both the forward and reverse primers are searched for.
    Both the original sequences and their reverse complements are
    searched for, in case the read is on the opposite strand.
    &#34;&#34;&#34;
    # Select verbosity #
    import tqdm
    wrapper = tqdm.tqdm if verbose else lambda x: x
    # Shorter name for the distance allowed #
    dist = self.primer_max_dist
    # Loop #
    for r in wrapper(reads):
        # Use this for debugging purposes #
        if debug: print(r.pretty_visualization)
        # Did we find both primers? #
        fwd_found = r.fwd_srt is not None or r.fwd_rc_srt is not None
        rev_found = r.rev_srt is not None or r.rev_rc_srt is not None
        # Skip reads that don&#39;t pass this criteria #
        if not fwd_found or not rev_found: continue
        # These situations should not occur, could be long chimeras #
        if r.fwd_srt is not None    and r.rev_srt is not None:    continue
        if r.fwd_rc_srt is not None and r.rev_rc_srt is not None: continue
        # We are in a forward sequence situation #
        if r.fwd_srt is not None and r.rev_rc_srt is not None:
            if dist and r.fwd_srt                 &gt; dist: continue
            if dist and len(r.seq) - r.rev_rc_end &gt; dist: continue
            out = r.read[r.fwd_end:r.rev_rc_srt]
            if len(out) == 0: continue
        # We are in a reverse complemented situation #
        if r.fwd_rc_srt is not None and r.rev_srt is not None:
            if dist and r.rev_srt                 &gt; dist: continue
            if dist and len(r.seq) - r.fwd_rc_end &gt; dist: continue
            out = r.read[r.rev_end:r.fwd_rc_srt].reverse_complement()
            if len(out) == 0: continue
        # Return #
        yield out</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.score_filter"><code class="name flex">
<span>def <span class="ident">score_filter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_filter(self):
    # Optionally bypass this step #
    if self.phred_window_size is None or self.phred_threshold is None:
        self.score_fastq.copy(self.length_fastq)
    # Perform the score filtering #
    self.score_fastq.write(self.score_gen(self.length_fastq))</code></pre>
</details>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilter.score_gen"><code class="name flex">
<span>def <span class="ident">score_gen</span></span>(<span>self, reads)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_gen(self, reads):
    # Parameters #
    window    = self.phred_window_size
    threshold = self.phred_threshold
    # Loop #
    for r in reads:
        quality = pandas.Series(r.letter_annotations[&#39;phred_quality&#39;])
        rolling = quality.rolling(window).mean().dropna().tolist()
        if any(score &lt; threshold for score in rolling): continue
        yield r</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pacmill.filtering.seq_filter.SeqFilterResults"><code class="flex name class">
<span>class <span class="ident">SeqFilterResults</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SeqFilterResults(object):

    def __init__(self, parent):
        # Reference to the SeqFilter instance #
        self.parent = parent
        # The intermediary steps #
        self.primers_fastq = parent.primers_fastq
        self.n_base_fastq  = parent.n_base_fastq
        self.length_fastq  = parent.length_fastq
        self.score_fastq   = parent.score_fastq
        self.renamed_fastq = parent.renamed_fastq
        # The final result #
        self.clean = self.renamed_fastq</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pacmill.filtering" href="index.html">pacmill.filtering</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pacmill.filtering.seq_filter.SeqFilter" href="#pacmill.filtering.seq_filter.SeqFilter">SeqFilter</a></code></h4>
<ul class="two-column">
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.all_paths" href="#pacmill.filtering.seq_filter.SeqFilter.all_paths">all_paths</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.autopaths" href="#pacmill.filtering.seq_filter.SeqFilter.autopaths">autopaths</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.len_filter" href="#pacmill.filtering.seq_filter.SeqFilter.len_filter">len_filter</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.len_gen" href="#pacmill.filtering.seq_filter.SeqFilter.len_gen">len_gen</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.max_read_len" href="#pacmill.filtering.seq_filter.SeqFilter.max_read_len">max_read_len</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.min_read_len" href="#pacmill.filtering.seq_filter.SeqFilter.min_read_len">min_read_len</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.n_base_filter" href="#pacmill.filtering.seq_filter.SeqFilter.n_base_filter">n_base_filter</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.n_base_gen" href="#pacmill.filtering.seq_filter.SeqFilter.n_base_gen">n_base_gen</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.phred_threshold" href="#pacmill.filtering.seq_filter.SeqFilter.phred_threshold">phred_threshold</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.phred_window_size" href="#pacmill.filtering.seq_filter.SeqFilter.phred_window_size">phred_window_size</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.primer_filter" href="#pacmill.filtering.seq_filter.SeqFilter.primer_filter">primer_filter</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.primer_gen" href="#pacmill.filtering.seq_filter.SeqFilter.primer_gen">primer_gen</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.primer_max_dist" href="#pacmill.filtering.seq_filter.SeqFilter.primer_max_dist">primer_max_dist</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.primer_mismatches" href="#pacmill.filtering.seq_filter.SeqFilter.primer_mismatches">primer_mismatches</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.primer_positions" href="#pacmill.filtering.seq_filter.SeqFilter.primer_positions">primer_positions</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.results" href="#pacmill.filtering.seq_filter.SeqFilter.results">results</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.score_filter" href="#pacmill.filtering.seq_filter.SeqFilter.score_filter">score_filter</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.score_gen" href="#pacmill.filtering.seq_filter.SeqFilter.score_gen">score_gen</a></code></li>
<li><code><a title="pacmill.filtering.seq_filter.SeqFilter.short_name" href="#pacmill.filtering.seq_filter.SeqFilter.short_name">short_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pacmill.filtering.seq_filter.SeqFilterResults" href="#pacmill.filtering.seq_filter.SeqFilterResults">SeqFilterResults</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>